# **学習方法の実装状況と選択ガイド**

このドキュメントは、matsushibadenki/dora プロジェクトにおける各種学習アルゴリズムの実装状況を整理し、目的や制約に応じた適切な手法を選択するための指針を示します。

## **1\. 実装状況一覧表**

現在の実装レベルを以下の3段階で分類しています。

* ✅ **Core**: 中核実装済み。動作確認が取れており、推奨される。  
* ⚠️ **Experimental**: 実験的実装。特定のモデルや条件下でのみ動作、または調整中。  
* ❌ **Draft**: 枠組みのみ。ファイルは存在するがロジックが未実装、または空の状態。

| カテゴリ | 学習手法 | 実装状況 | 主要ファイル | 推奨度 | 用途 |
| :---- | :---- | :---- | :---- | :---- | :---- |
| **生体模倣** | **STDP** (Spike-Timing Dependent Plasticity) | ✅ Core | core/synapse\_dynamics.py learning\_rules/stdp.py | ★★★ | 教師なし学習、特徴抽出、自己組織化 |
|  | **Hebbian / BCM** | ✅ Core | learning\_rules/probabilistic\_hebbian.py learning\_rules/bcm\_rule.py | ★★☆ | 連想記憶、恒常性維持 |
| **代替BP** | **Forward-Forward** | ✅ Core | training/trainers/forward\_forward.py learning\_rules/forward\_forward.py | ★★★ | 深層SNNの省メモリ学習、エッジデバイス向け |
|  | **Predictive Coding** | ⚠️ Exp | models/experimental/predictive\_coding\_model.py | ★☆☆ | 予測符号化モデルの研究、次状態予測 |
| **強化学習** | **Spike PPO** | ✅ Core | training/rl/spike\_ppo.py | ★★★ | エージェントの行動決定、ロボット制御 |
|  | **Spike SAC** | ⚠️ Exp | training/rl/spike\_sac.py | ★☆☆ | より複雑な連続値制御（調整難易度高） |
| **高速化** | **SARA Engine (Rust)** | ✅ Core | models/experimental/sara\_engine.py rust\_kernel/src/lib.rs | ★★★ | **大規模・高速シミュレーション**、ハイブリッド実行 |
| **補助・応用** | **Knowledge Distillation** | ✅ Core | training/trainers/distillation.py distillation/ | ★★☆ | モデル圧縮、SNNへの知識転移 |
|  | **Sleep Consolidation** | ✅ Core | cognitive\_architecture/sleep\_consolidation.py | ★★☆ | **継続学習**、破滅的忘却の防止 |
| **未実装枠** | **Active Inference** | ❌ Draft | adaptive/active\_inference\_agent.py | \--- | 能動的推論（計画中） |
|  | **Concept Augmented** | ❌ Draft | training/trainers/concept\_augmented\_trainer.py | \--- | 概念学習（計画中） |

## **2\. 主要な学習方法の詳細と選択指針**

### **A. SARA Engine \+ Rust Kernel (最優先推奨)**

プロジェクトのコアとなる、Rust言語による高速化バックエンドとPython（PyTorch）のハイブリッドエンジンです。

* **概要**: Python側で高次機能（意識、感情、API連携）を制御し、Rustカーネル側で計算負荷の高いスパイク伝播とSTDP学習を並列処理します。  
* **選択指針**:  
  * **大規模なSNN**を構築する場合。  
  * **リアルタイム性**が求められる場合。  
  * 純粋なPyTorch実装では速度が出ない場合。  
* **注意点**: Rust環境のビルドが必要です。

### **B. Forward-Forward Algorithm (Hinton's FF)**

バックプロパゲーション（誤差逆伝播法）を使用せず、層ごとに局所的に学習を進める手法です。

* **概要**: 「Positive Data（実データ）」と「Negative Data（偽データ）」をネットワークに入力し、実データの「Goodness」を上げ、偽データの「Goodness」を下げるように学習します。  
* **選択指針**:  
  * **GPUメモリが限られている**場合（層ごとの学習で済むため）。  
  * 生物学的に妥当な深層学習を行いたい場合。  
  * 従来のSNN学習（Surrogate Gradient）が不安定な場合。

### **C. STDP (Spike-Timing Dependent Plasticity)**

「ニューロンが発火したタイミング」に基づいてシナプス結合強度を強化・弱化させる、SNNの基本となる局所学習則です。

* **概要**: 前シナプススパイクが後シナプススパイクの直前に来れば強化（LTP）、直後に来れば弱化（LTD）します。  
* **選択指針**:  
  * **教師なし**で入力データの統計的特徴（パターン）を学習させたい場合。  
  * 視覚野（V1）のようなエッジ検出フィルタを自動獲得させたい場合。  
  * Rust Kernelを使用する場合（カーネル内にハードコードされており高速）。

### **D. Spike PPO (Proximal Policy Optimization)**

スパイクニューラルネットワークを用いた強化学習アルゴリズムの安定版です。

* **概要**: エージェントが環境から報酬を得るタスクにおいて、報酬期待値を最大化するポリシーを学習します。  
* **選択指針**:  
  * **ロボティクス制御**や**ゲームAI**など、行動を学習させる場合。  
  * 教師データが存在せず、試行錯誤から学習する必要がある場合。

### **E. Sleep Consolidation (記憶定着メカニズム)**

覚醒中に蓄積した経験を「睡眠」フェーズで再生（Replay）し、長期記憶へ定着させる仕組みです。

* **概要**: 短期記憶バッファ（海馬モデル等）の内容を、STDPなどを用いて長期記憶ネットワーク（皮質モデル）へ転送・焼き付けを行います。  
* **選択指針**:  
  * \*\*継続学習（Continual Learning）\*\*を行う場合。  
  * 新しいタスクを学習すると古いタスクを忘れてしまう（破滅的忘却）を防ぎたい場合。

## **3\. 学習方法選択フローチャート**

graph TD  
    Start\[学習タスクの開始\] \--\> Q1{教師データはあるか？}  
      
    Q1 \-- Yes \--\> Q2{タスクの種類は？}  
    Q1 \-- No \--\> Q3{環境からの報酬はあるか？}  
      
    Q3 \-- Yes (行動学習) \--\> RL\[Spike PPO\]  
    Q3 \-- No (パターン認識) \--\> STDP\[STDP / Hebbian\]  
      
    Q2 \-- 識別/回帰 \--\> Q4{計算リソース/制約は？}  
    Q2 \-- 知識転移 \--\> Distil\[Knowledge Distillation\]  
      
    Q4 \-- メモリ制約大/Deep化 \--\> FF\[Forward-Forward\]  
    Q4 \-- 速度重視/大規模 \--\> SARA\[SARA Engine \+ Rust Kernel\]  
    Q4 \-- 汎用的な学習 \--\> BP\[Surrogate Gradient (PyTorch標準)\]  
      
    Sub1\[継続学習が必要？\] \--\> |Yes| Sleep\[Sleep Consolidation 追加\]

## **4\. 今後のアクション推奨**

1. **SARA Engineの標準化**:  
   * 可能な限り snn\_research/models/experimental/sara\_engine.py をベースクラスとして利用し、Rustによる高速化の恩恵を受けるように設計を統一する。  
2. **未実装機能の判断**:  
   * Active Inference (能動的推論) や Concept Augmented は現在プレースホルダーです。これらが必要なプロジェクトでなければ、混乱を避けるためにコードベースから一時的に退避させるか、優先度を下げて管理してください。  
3. **ドキュメントの更新**:  
   * 新しい学習ルール（例: 新しいSTDPのバリエーションなど）を追加した場合は、この一覧表を更新してください。